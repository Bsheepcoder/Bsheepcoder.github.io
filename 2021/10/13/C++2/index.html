

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/page1.png">
  <link rel="icon" href="/img/page1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#000000">
  <meta name="description" content="主要学习了mooc中的北京大学的C++课程，关于C++11的新特性也有相关介绍。">
  <meta name="author" content="Tony">
  <meta name="keywords" content="">
  <meta name="description" content="主要学习了mooc中的北京大学的C++课程，关于C++11的新特性也有相关介绍。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++系列：类和对象基础（二）">
<meta property="og:url" content="https://bsheepcoder.github.io/2021/10/13/C++2/index.html">
<meta property="og:site_name" content="Q&#39;s blog">
<meta property="og:description" content="主要学习了mooc中的北京大学的C++课程，关于C++11的新特性也有相关介绍。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/07/iEwLyzpkUBrToA2.png">
<meta property="article:published_time" content="2021-10-12T23:17:31.829Z">
<meta property="article:modified_time" content="2022-03-04T02:46:09.087Z">
<meta property="article:author" content="Tony">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/10/07/iEwLyzpkUBrToA2.png">
  
  <title>C++系列：类和对象基础（二） - Q&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/tomorrow-night-bright.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/diy/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"bsheepcoder.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":5,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#efec02","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading2.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"0wpY18jIxyDKS5O89Sd6fFGh-gzGzoHsz","app_key":"8y2ItNdFctdKBPMHS31S2jbm","server_url":"https://0wpy18ji.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Q&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/w/w1.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++系列：类和对象基础（二）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-13 07:17" pubdate>
        2021年10月13日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      58 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++系列：类和对象基础（二）</h1>
            
              <p class="note note-info">
                
                  更新于：2022年3月4日 上午
                
              </p>
            
            <div class="markdown-body">
              <p>更多参考其他文档<a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-tutorial.html">菜鸟文档</a>、<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/cpp/">W3C</a>、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/cpp/?view=msvc-160">微软C++文档</a></p>
<h2 id="类和对象基础"><a href="#类和对象基础" class="headerlink" title="类和对象基础"></a>类和对象基础</h2><h3 id="类和对象基本概念"><a href="#类和对象基本概念" class="headerlink" title="类和对象基本概念"></a>类和对象基本概念</h3><ul>
<li>类的成员函数和类的定义分开写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//类的成员函数和类的定义分开写</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CRectangle</span>  //定义一个类</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-keyword">int</span> w,h;   <br>    	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Area</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//此处函数可以先声明，并不写出函数体</span><br>    	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Perimeter</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//此处函数可以先声明，并不写出函数体</span><br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w_,<span class="hljs-keyword">int</span> h_)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CRectangle::Area</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//类中的函数实体可以写到函数外</span><br>    <span class="hljs-keyword">return</span> w * h;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CRectangle::Perimeter</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (w + h);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CRectangle::Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w_,<span class="hljs-keyword">int</span> h_)</span></span>&#123;<br>     w = w_; h = h_;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>类成员的可访问范围</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//在类的定义中，用下来关键字来说明类成员的可被访问的范围</span><br> - <span class="hljs-keyword">private</span> : 私有成员，只能在函数内访问<br> - <span class="hljs-keyword">public</span> ：公有成员，可以在任何地方访问<br> - <span class="hljs-keyword">protected</span>:保护成员，以后再说<br> <span class="hljs-comment">//出现的顺序没有限制</span><br>     <br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">className</span> &#123;</span><br>     <span class="hljs-keyword">private</span>:<br>     	私有属性和函数<br>     <span class="hljs-keyword">public</span> ：<br>            公有属性和函数<br>     <span class="hljs-keyword">protected</span>:<br>            保护属性和函数<br> &#125;;<br><br><span class="hljs-comment">//一般的，如果某个类的成员前面没有上述关键字，则被认为是私有成员</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span>&#123;</span><br>    <span class="hljs-keyword">int</span> nAge;<span class="hljs-comment">//私有</span><br>    <span class="hljs-keyword">char</span> szName[<span class="hljs-number">20</span>];<span class="hljs-comment">//私有</span><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetName</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * szName)</span>  <span class="hljs-comment">//公有</span></span><br><span class="hljs-function">    </span>&#123;<br>		<span class="hljs-built_in">strcpy</span>(Man::szName,szName);<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure>
<ul>
<li>访问范围</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//在当前类、函数的成员函数内部，能够访问：</span><br>- 当前对象的全部函数、属性；<br>- 同类其它对象的全部属性、函数；<br><span class="hljs-comment">//在类的成员函数以外的地方，只能够访问该类对象的公有成员，私有成员不能访问</span><br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CEemployee</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">char</span> szName[<span class="hljs-number">30</span>];<span class="hljs-comment">//名字</span><br>    <span class="hljs-keyword">public</span>：<br>        <span class="hljs-keyword">int</span> salary;<span class="hljs-comment">//工资</span><br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * name)</span></span>;<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * name)</span></span>;<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">averageSalary</span><span class="hljs-params">(CEmployee e1,CEmployee e2)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CEmplotyee::setName</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * name)</span></span>&#123;<br>    <span class="hljs-built_in">strcpy</span>(szName,name);<span class="hljs-comment">//可以访问私有的szName</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CEmployee::getName</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * name)</span></span>&#123;<br>    <span class="hljs-built_in">strcpy</span>(name,szName); <span class="hljs-comment">//ok</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CEmployee::averageSalary</span><span class="hljs-params">(CEmployee e1,CEmployee e2)</span></span>&#123;<br>    cout&lt;&lt;e1.szName;<span class="hljs-comment">//ok</span><br>    salary = (e1.salary + e2.salary)/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CEmployee e;<br>    <span class="hljs-built_in">strcpy</span>(e.szName,<span class="hljs-string">&quot;Tom1234567889&quot;</span>);<span class="hljs-comment">// 编译错，不能访问私有成员</span><br>    e.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;Tom&quot;</span>); <span class="hljs-comment">// ok</span><br>    e.salary = <span class="hljs-number">5000</span>;  <span class="hljs-comment">//ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//隐藏</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CEmployee e;<br>    <span class="hljs-built_in">strcpy</span>(e.szName,<span class="hljs-string">&quot;Tom1234567889&quot;</span>);<span class="hljs-comment">//编译错，不能访问私有成员</span><br>    e.<span class="hljs-built_in">setNName</span>(<span class="hljs-string">&quot;Tom&quot;</span>); <span class="hljs-comment">//ok</span><br>    e.salary = <span class="hljs-number">5000</span>; <span class="hljs-comment">// ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//设置私有成员的机制叫“隐藏”</span><br>“隐藏”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。<br>    <br><span class="hljs-comment">//例--</span><br>当一个程序移植到小内存的设备上时，会有例如将 szName[<span class="hljs-number">30</span>] 改为 szName[<span class="hljs-number">5</span>] 的需求，如果不在程序中设置为私有成员，那么程序中会有很多下面这样的语句：<br><span class="hljs-built_in">strcpy</span>(e.szName,<span class="hljs-string">&quot;Tom1234567889&quot;</span>);<br>此时，相关的语句也会报错，要一个一个修改，设置为私有后，我们就不会有上面的语句出现，可以通过如setName函数 来实现:<br>e.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;Tom12345678909887&quot;</span>);<br>这样，即便有这样的需求我们只需要将set函数做修改就行<br><br><br></code></pre></div></td></tr></table></figure>
<h4 id="成员函数的重载及参数缺省"><a href="#成员函数的重载及参数缺省" class="headerlink" title="成员函数的重载及参数缺省"></a>成员函数的重载及参数缺省</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//成员函数的重载及参数缺省</span><br><span class="hljs-comment">//成员函数可以带缺省参数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Location</span> &#123;</span><br>    <span class="hljs-keyword">private</span> :<br>    	<span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">//函数中有两个缺省参数</span><br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">valueX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;x = val;&#125;<br>    	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">valueX</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> x;&#125;       <span class="hljs-comment">//这里用了重载，即两个函数名相同，但是参数不同</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Location A,B;<br>    A.<span class="hljs-built_in">init</span>(<span class="hljs-number">5</span>);       <span class="hljs-comment">//少了的参数用缺省值，0</span><br>    A.<span class="hljs-built_in">valueX</span>(<span class="hljs-number">5</span>);        <span class="hljs-comment">//调用时，注意避免二义性</span><br>    cout&lt;&lt;A.<span class="hljs-built_in">valueX</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//二义性报错！！</span><br><span class="hljs-comment">//二义性报错！！</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Location</span> &#123;</span><br>    <span class="hljs-keyword">private</span> :<br>    	<span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>)</span></span>; <br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">valueX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>)</span></span>&#123;x = val;&#125;  <span class="hljs-comment">//这里使用了缺省参数0</span><br>    	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">valueX</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> x;&#125;       <span class="hljs-comment">//这里其实也是相当于为0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Location A,B;<br>    A.<span class="hljs-built_in">init</span>(<span class="hljs-number">5</span>);   <br>    A.<span class="hljs-built_in">valueX</span>();        <span class="hljs-comment">//如果此时调用，就会报错，存在二义性，计算机不知道调用哪个函数</span><br>    cout&lt;&lt;A.<span class="hljs-built_in">valueX</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="构造函数（constructor）"><a href="#构造函数（constructor）" class="headerlink" title="构造函数（constructor）"></a>构造函数（constructor）</h3><p>构造函数是成员函数的一种，<strong>名字  与  类名</strong>  <strong>相同</strong>，可以有参数，不能有返回值(void 也不行)</p>
<p>作用：对对象进行初始化，如给成员变量赋初值</p>
<p><strong>如果定义类时没有写构造参数，则编译器生成一个默认的无参数的构造函数</strong></p>
<p>默认构造函数无参数，不做任何操作</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//基本概念</span><br>类如果定义了构造函数，则编译器不生成默认的无参数的构造函数<br>对象生成时，构造函数自动被调用。对象一旦生成，就再也不能在其执行构造函数<br>一个类可以有多个构造函数<br><span class="hljs-comment">//为什么需要构造函数</span><br>    构造函数执行必要的初始化工作，有了构造函数，就不必专门写初始化函数，也不用担心忘记调用初始化函数。<br>    对象没有被初始化，容易出错<br>    <br><span class="hljs-comment">//例1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">double</span> real,imag;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i)</span></span>;<br>&#125;;<span class="hljs-comment">//编译器自动生成默认构造函数</span><br><br>Complex cl;<span class="hljs-comment">//默认构造函数被调用</span><br>Complexa * pc = newComeplex;<span class="hljs-comment">//默认构造函数被调用</span><br><br><span class="hljs-comment">//例2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    		<span class="hljs-keyword">double</span> real,imag;<br>    <span class="hljs-keyword">public</span>:<br>    		<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>);<br>&#125;;<br>Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i)&#123;<br>    real = r;imag = i;<br>&#125;<br>Complex c1; <span class="hljs-comment">//error 缺少构造函数的参数</span><br>Complex * pc = <span class="hljs-keyword">new</span> Complex; <span class="hljs-comment">//error 也是因为没有参数</span><br><span class="hljs-function">Complex <span class="hljs-title">C1</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">//OK  提供了参数，i 是 = 0的缺省参数，所以传一个参数就可以</span><br><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)</span>,<span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;  <br>Complex * pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br></code></pre></div></td></tr></table></figure>
<p>一个类可以有多个构造函数，只要这些类的参数个数或类型不同就可以，类似函数重载，也用于初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">double</span> real,imag;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i)</span></span>;<br>    	<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i);    <span class="hljs-comment">//重载的关系</span><br>    	<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r);              <span class="hljs-comment">//重载的关系</span><br>   		<span class="hljs-built_in">Complex</span>(Complex c1,Complex c2);  <span class="hljs-comment">//重载的关系</span><br>&#125;;<br>Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i)  <span class="hljs-comment">//构造函数1</span><br>&#123;<br>    real = r; imag = i;<br>&#125;<br>Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r)   <span class="hljs-comment">//构造函数2</span><br>&#123;<br>    real = r; imag = <span class="hljs-number">0</span>;<br>&#125;<br>Complex::<span class="hljs-built_in">Complex</span>(Complex c1,Complex c2);  <span class="hljs-comment">//构造函数3</span><br>&#123;<br>    real = cl.real + c2.real;   <span class="hljs-comment">//对应相加</span><br>    imag = cl.imag + c2.imag;   <br>&#125;<br><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;    <span class="hljs-comment">//对应构造函数2，表示赋初始值为（3，0）</span><br><span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">//对应构造函数1，表示赋初始值为（1，0）</span><br><span class="hljs-function">Complex <span class="hljs-title">c3</span><span class="hljs-params">(c1,c2)</span></span>;    <span class="hljs-comment">//对应构造函数3，表示赋初始值为（4，0）</span><br><br></code></pre></div></td></tr></table></figure>
<h4 id="构造函数在数组中的使用"><a href="#构造函数在数组中的使用" class="headerlink" title="构造函数在数组中的使用"></a>构造函数在数组中的使用</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSample</span> &#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">CSample</span>()&#123;    <span class="hljs-comment">//无参数构造函数</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;Constructor 1 Called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    	<span class="hljs-built_in">CSample</span>(<span class="hljs-keyword">int</span> n)&#123;   <span class="hljs-comment">//有参构造函数</span><br>            x = n;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Constructor 2 Called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CSample array1[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 2个变量都 没有 参数，则默认使用没给参数的构造函数</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;step1&quot;</span>&lt;&lt;endl;<br>    <br>    CSample array2[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">// 2个变量都 有 参数，则默认使用给参数的构造函数</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;step2&quot;</span>&lt;&lt;endl;<br>    <br>    CSample array3[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>&#125;; <br>    <span class="hljs-comment">//一个有参数，一个无参数，则有参数的用有参构造函数初始化，无参的用无参构造函数初始化</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;step3&quot;</span>&lt;&lt;endl;<br>    <br>    CSample *array4 = <span class="hljs-keyword">new</span> CSample[<span class="hljs-number">2</span>];   <span class="hljs-comment">//没有参数用无参</span><br>    <span class="hljs-keyword">delete</span> []array4;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//分割线----------------------------------------------------</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;</span><br>    pulic:<br>    	<span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> n)&#123;&#125;  <span class="hljs-comment">//构造1</span><br>    	<span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)&#123;&#125;  <span class="hljs-comment">//构造2</span><br>   		<span class="hljs-built_in">Test</span>()&#123;&#125;  <span class="hljs-comment">//构造3</span><br>&#125;<br>Test array1[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>，<span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&#125;;  <span class="hljs-comment">//三个元素分别于1，2，3构造初始化</span><br><br>Test array2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-built_in">Test</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//三个元素分别用2，2，1初始化</span><br><br>Test * Parray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">4</span>),<span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&#125;; <span class="hljs-comment">// 1，2   Parray[2]没有被初始化！</span><br></code></pre></div></td></tr></table></figure>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>只有一个参数，即对同类对象的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">形式：  <br>X::<span class="hljs-built_in">X</span>(X &amp;)<br>    <br>X::<span class="hljs-built_in">X</span>(<span class="hljs-keyword">const</span> X &amp;)  <span class="hljs-comment">//可以常量对象作为参数</span><br>    <br>如果没有定义复制构造函函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。<br>    <br><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>==无参的构造函数==也叫默认构造函数==不一定存在==，没有任何构造函数编译器就会生成无参构造函数，写了构造函数系统就不会生成无参构造函数</p>
</li>
<li><p>==复制构造函数一定存在==，你不写编译器就帮你形成。</p>
</li>
<li><p>==构造函数不一定是无参的==，有了构造函数，就不会自动生成无参构造函数了</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//复制构造函数概念</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">double</span> real,imag;<br>&#125;;<br>Complex c1; <span class="hljs-comment">//无参构造函数初始化</span><br><span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(c1)</span></span>; <span class="hljs-comment">//复制构造函数，将c2初始化成和c1一样，复制的工作</span><br></code></pre></div></td></tr></table></figure>
<h4 id="复制构造函数起作用的三种情况"><a href="#复制构造函数起作用的三种情况" class="headerlink" title="复制构造函数起作用的三种情况"></a>复制构造函数起作用的三种情况</h4><ul>
<li><p>当用一个对象去初始化同类的另一个对象时。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(c1)</span></span>;<br><br>Complex c2 = c1; <span class="hljs-comment">//初始化语句，非赋值语句，与上面等价</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">A</span>()&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(A &amp; a)&#123;<br>        cout &lt;&lt;<span class="hljs-string">&quot;Copy constructor called&quot;</span>&lt;&lt;endl;<br>         <span class="hljs-comment">//没有写复制的语句</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(A a1)</span></span>&#123;&#125;  <span class="hljs-comment">//参数传递后有一个复制的工作</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a2;<br>    <span class="hljs-built_in">Func</span>(a2);  <span class="hljs-comment">//此时a1就是a2的复制品</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//如果自己写了复制构造函数，但是里面没有写复制的语句，则上面就不能完成复制，则此时形参就不一定是实参的拷贝</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">A</span>()&#123;&#125;;<br>    <span class="hljs-built_in">A</span>(A &amp; a)&#123;<br>        cout &lt;&lt;<span class="hljs-string">&quot;Copy constructor called&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-comment">//没有写复制的语句</span><br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> v;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> n) &#123; v = n; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp; a)&#123;  <span class="hljs-comment">//复制构造函数</span><br>        v = a.v;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Copy constructor called&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">Func</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//是返回类型为对象的函数</span><br>    <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> b;   <span class="hljs-comment">//这是复制构造函数的参数</span><br>    <span class="hljs-comment">//在函数返回时，通过复制构造函数，使得返回值赋值为b.v </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">Func</span>().v&lt;&lt;endl;  <span class="hljs-comment">//输出的是返回值对象的V，相当于b.v</span><br>    <span class="hljs-comment">//Fun函数返回时，复制了b.v</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>==总结三种情况：用一个对象初始化另一个对象、函数的形参是个对象、函数的返回值是对象==</p>
<p>注意：对象间的赋值并不导致复制构造函数被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CMyclass</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">CMyclass</span>()&#123;&#125;;<br>        <span class="hljs-built_in">CMyclass</span>(CMyclass &amp; c)&#123;n = <span class="hljs-number">2</span> * c.n;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    CMyclass c1,c2;<br>    c1.n = <span class="hljs-number">5</span>;  <span class="hljs-comment">//</span><br>    c2 = c1;   <span class="hljs-comment">//单纯的对象间的赋值操作不会导致复制构造函数被调用，类似结构体赋值</span><br>    <span class="hljs-function">CMyclass <span class="hljs-title">c3</span><span class="hljs-params">(c1)</span></span>;  <span class="hljs-comment">//这里使用了复制构造函数，但是函数内做的不是复制的工作</span><br>    cout &lt;&lt;<span class="hljs-string">&quot;c2.n=&quot;</span>&lt;&lt; c2.n &lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    cout &lt;&lt;<span class="hljs-string">&quot;c3.n=&quot;</span>&lt;&lt; c3.n &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="常量引用参数"><a href="#常量引用参数" class="headerlink" title="常量引用参数"></a>常量引用参数</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(CMyclass obj_)</span></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;fun&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大。</span><br><span class="hljs-comment">//所以可以考虑使用CMyclass &amp; 引用类型作为参数。</span><br><span class="hljs-comment">//如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字：</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CMyclass &amp; obj)</span></span>&#123;<br>    <span class="hljs-comment">//在函数中任何试图改变obj值的语句都将变成非法</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>为什么要自己写构造函数？？？？</p>
<h4 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h4><p>定义转换构造函数的目的是==实现类型的自动转换== </p>
<p>==只有一个参数==，而且==不是复制构造函数的构造函数==，一般就可以看作是转换构造函数。</p>
<p>当需要的时候，==编译系统自动调用转换构造函数== ，建立一个无名的临时对象（或临时变量）。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><br>    <span class="hljs-keyword">public</span> : <br>    	<span class="hljs-keyword">double</span> real,imag;<br>    	<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">int</span> i)&#123;  <span class="hljs-comment">//类型转换构造函数</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;IntConstructor called&quot;</span>&lt;&lt; endl;<br>            real  = i ; imag =<span class="hljs-number">0</span>;<br>        &#125;<br>    	<span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i)&#123;real = r; imag = i;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)</span></span>;<br>    Complex c2 = <span class="hljs-number">12</span>; <span class="hljs-comment">//调用了Complex()构造函数，real = 12，imag = 0；</span><br>    c1 = <span class="hljs-number">9</span>; <span class="hljs-comment">// 9被自动转换成一个临时Complex对象，值为（9，0）然后进行赋值</span><br>    cout &lt;&lt; c1.real&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;c1.imag &lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>==名字与类名相同== ，==在前面加‘ ~’ ,没有参数和返回值== ，一个==类== 最多==只能有一个析构函数== 。</p>
<p>析构函数对象消亡时象消亡时即自动被调用。用来在对象消亡前做善后工作，比如==释放分配的空间== 等。</p>
<p>如果定义类时==没写析构函数==，则编==译器生成缺省析构函数== ，缺省析构函数==什么也不做== 。</p>
<p>如果定义了析构函数，则编译器就不在定义缺省的析构函数了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>&#123;</span><br>    <span class="hljs-keyword">private</span> :<br>    	<span class="hljs-keyword">char</span> * p;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">String</span>()&#123;<br>            p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];<br>        &#125;<br>    	~ <span class="hljs-built_in">String</span>();<br>&#125;<br>String ::~<span class="hljs-built_in">String</span>()&#123;<br>    <span class="hljs-keyword">delete</span> [] p;  <span class="hljs-comment">//释放内存 </span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="析构函数和数组"><a href="#析构函数和数组" class="headerlink" title="析构函数和数组"></a>析构函数和数组</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ctest</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Ctest</span>()&#123; cout&lt;&lt;<span class="hljs-string">&quot;destryctor called&quot;</span>&lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Ctest array[<span class="hljs-number">2</span>];  <span class="hljs-comment">//数组消亡，数组中每个元素依次调用消亡，故会输出两行destrytor 。。</span><br>    cout &lt;&lt;<span class="hljs-string">&quot;End Main&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="析构函数和运算符delete"><a href="#析构函数和运算符delete" class="headerlink" title="析构函数和运算符delete"></a>析构函数和运算符delete</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Ctest * pTest;<br>pTest = <span class="hljs-keyword">new</span> Ctest; <span class="hljs-comment">//构造函数调用</span><br><span class="hljs-keyword">delete</span> pTest;            <span class="hljs-comment">//析构函数调用</span><br><span class="hljs-comment">//---------------------------------</span><br>pTest = <span class="hljs-keyword">new</span> Ctest[<span class="hljs-number">3</span>];  <span class="hljs-comment">//构造函数调用 3 次</span><br><span class="hljs-keyword">delete</span> [] pTest;     <span class="hljs-comment">//析构函数调用 3 次， 动态数组消亡的写法</span><br><br> <span class="hljs-comment">//若new 一个对象数组，那么用delete释放时应该写[]。否则只delete一个对象（即调用依次析构函数）</span><br></code></pre></div></td></tr></table></figure>
<h4 id="析构函数在对象作为函数返回值返回后被调用"><a href="#析构函数在对象作为函数返回值返回后被调用" class="headerlink" title="析构函数在对象作为函数返回值返回后被调用"></a>析构函数在对象作为函数返回值返回后被调用</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CMyclass</span>&#123;</span><br>    <span class="hljs-keyword">public</span> :<br>    ~<span class="hljs-built_in">CMyclass</span>()&#123;cout &lt;&lt;<span class="hljs-string">&quot;destructor&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br>CMyclass obj;<br><span class="hljs-function">CMyclass <span class="hljs-title">fun</span><span class="hljs-params">(CMyclass sobj)</span></span>&#123;  <span class="hljs-comment">//参数对象消亡也会导致析构函数被调用  </span><br>    <span class="hljs-keyword">return</span> sobj;  <span class="hljs-comment">//返回时，函数形参对象消亡，调用复制构造函数  1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    obj = <span class="hljs-built_in">fun</span>(obj); <span class="hljs-comment">//函数调用的返回值被调用过后，该临时对象析构函数被调用  2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">//函数结束时，全体变量对象的析构函数被调用  3</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="构造函数和析构函数什么时候被调用"><a href="#构造函数和析构函数什么时候被调用" class="headerlink" title="构造函数和析构函数什么时候被调用"></a>构造函数和析构函数什么时候被调用</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">实例：<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demo</span>(<span class="hljs-keyword">int</span> i)&#123;   <span class="hljs-comment">//类型转换构造函数(只有一个参数的构造函数，)</span><br>        id = i;<br>        cout &lt;&lt;<span class="hljs-string">&quot;id=&quot;</span>&lt;&lt;id&lt;&lt;<span class="hljs-string">&quot;constructed&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Demo</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;id=&quot;</span>&lt;&lt;id&lt;&lt;<span class="hljs-string">&quot;destructed&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">Demo <span class="hljs-title">dl</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">//全局对象初始化引发构造函数，会输出id 1 =constructed</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Demo <span class="hljs-title">d2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 静态局部变量，函数结束时不消亡，程序结束消亡 </span><br>    <span class="hljs-function">Demo <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//定义d3类，函数结束时就消亡了</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;func&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Demo <span class="hljs-title">d4</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">//局部对象定义引发构造函数，输出 id 4 =constructed</span><br>    d4 = <span class="hljs-number">6</span>;    <span class="hljs-comment">//使用了的类型转换构造函数，创建了临时对象，id 6 =constructed</span><br>    <span class="hljs-comment">//结束后，临时对象消亡id 6 destructed;</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;main&quot;</span>&lt;&lt;endl;<br>    &#123;<br>        <span class="hljs-function">Demo <span class="hljs-title">d5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">//定义了d5 ,生存期为&#123;&#125; id 5 =constructed</span><br>    &#125;<span class="hljs-comment">//出了花括号，d5消亡，id 5 destructed;</span><br>    <span class="hljs-built_in">Func</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;main ends&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <span class="hljs-comment">//先定义初始化，后析构，先d2 消亡，后d1消亡</span><br><br><span class="hljs-comment">//delete时析构函数同样被调用！</span><br></code></pre></div></td></tr></table></figure>
<h4 id="复制构造函数在不同编译器中的表现"><a href="#复制构造函数在不同编译器中的表现" class="headerlink" title="复制构造函数在不同编译器中的表现"></a>复制构造函数在不同编译器中的表现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-keyword">int</span> x;<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x_):<span class="hljs-built_in">x</span>(x_)&#123;<br>            cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;constructor called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A&amp;a)&#123; <span class="hljs-comment">//dev需要这里的const，其他编译器不要</span><br>            x = <span class="hljs-number">2</span> +a.x;<br>            cout&lt;&lt;<span class="hljs-string">&quot;copy called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    	~<span class="hljs-built_in">A</span>()&#123;<br>            cout &lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;destructor called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-built_in">Af</span>()&#123;<br>    <span class="hljs-built_in">Ab</span>(<span class="hljs-number">10</span>);<br>	<span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    a = <span class="hljs-built_in">f</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/07/iEwLyzpkUBrToA2.png" srcset="/img/loading2.gif" lazyload alt="image-20210320182435205"></p>
<h3 id="类类型作函数参数的三种方式"><a href="#类类型作函数参数的三种方式" class="headerlink" title="类类型作函数参数的三种方式"></a>类类型作函数参数的三种方式</h3><p>c++依然采用传值的方式传递参数</p>
<h4 id="对象本身作为参数"><a href="#对象本身作为参数" class="headerlink" title="对象本身作为参数"></a>对象本身作为参数</h4><ul>
<li>使用对象本身作为参数时，形参时实参的一个拷贝，即调用了拷贝构造函数。最好自己定义一个明确的构造函数，以免发生不容易发现的错误。</li>
<li>多次调用拷贝构造函数，效率低</li>
</ul>
<h4 id="对象引用作为参数"><a href="#对象引用作为参数" class="headerlink" title="对象引用作为参数"></a>对象引用作为参数</h4><ul>
<li>推荐用这一种，容易理解使用，没有副作用，参考 引用 那里</li>
</ul>
<h4 id="对象指针作为参数"><a href="#对象指针作为参数" class="headerlink" title="对象指针作为参数"></a>对象指针作为参数</h4><ul>
<li>使指针指向实参对象，还是有指针空间的使用和释放，空间相对较小</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><h4 id="c-翻译到c"><a href="#c-翻译到c" class="headerlink" title="c++翻译到c"></a>c++翻译到c</h4><p>起初是没有c++编译器的，是将c++翻译到c</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCar</span>&#123;</span><br>	<span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetPrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>;<br>&#125;;<br><span class="hljs-keyword">void</span> CCar:：<span class="hljs-built_in">SetPrice</span>(<span class="hljs-keyword">int</span> p)<br>&#123;<br>    price = p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CCar car;<br>    car.<span class="hljs-built_in">SetPrice</span>(<span class="hljs-number">20000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>翻译为C语言,如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">sturct CCar &#123;<br>    <span class="hljs-keyword">int</span> price;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetPricr</span><span class="hljs-params">(struct CCar * <span class="hljs-keyword">this</span>,<span class="hljs-keyword">int</span> p)</span>  <span class="hljs-comment">//增加了this指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;pricr = p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CCar</span> <span class="hljs-title">car</span>;</span><br>    SetPrice(&amp;car,<span class="hljs-number">20000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>C++中的成员函数到了C中就会成为全局函数，并且在参数中多出一项this指针，这个this指针含义是指向被作用的对象</p>
<p>this指针的作用： ==指向成员函数所作用的对象==</p>
<p> ==非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针==</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">double</span> real imag;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt; real&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;imag;<br>    &#125;<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> i):<span class="hljs-built_in">real</span>(r),<span class="hljs-built_in">imag</span>(i)<br>    &#123;  &#125;<br>    <span class="hljs-function">Complex <span class="hljs-title">AddOne</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;real ++;   <span class="hljs-comment">//等价于real++ ,this指向这个函数作用的对象</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Print</span>();  <span class="hljs-comment">//等价于 Print()</span><br>        <span class="hljs-keyword">return</span> * <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span>,<span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br>    c2 =c1.<span class="hljs-built_in">AddOne</span>();<span class="hljs-comment">//c1 real + 1,并且输出了2，1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//看着有点怪，但是正确的例子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A*p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">Hello</span>();  <span class="hljs-comment">//相当于hello(p)</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-comment">//转化为，void Hello(A * this)&#123;cout&lt;&lt; this-&gt;i &lt;&lt;&quot;hello&quot;&lt;&lt;endl;&#125;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A*p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">Hello</span>();  <span class="hljs-comment">//相当于hello(p)</span><br>&#125;<br><span class="hljs-comment">//静态成员函数中不能使用this指针！</span><br>    因为静态成员函数并不具体作用于某个对象<br>        因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数<br></code></pre></div></td></tr></table></figure>
<h3 id="“-”在c-中的作用"><a href="#“-”在c-中的作用" class="headerlink" title="“ :  ”在c++中的作用"></a>“ :  ”在c++中的作用</h3><p>对目标x 初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">100</span>;  <span class="hljs-comment">//const 声明或定义的变量是不能被赋值的，但是在下面的语句中，可以通过初始化，来改变它的初始值</span><br>    	<span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x_):<span class="hljs-built_in">x</span>(x_)&#123;  <span class="hljs-comment">//: 后的x是指函数中的x，意思是用x_也可以是数字，将x初始化</span><br>            cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;constructor called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> abc = <span class="hljs-number">0</span>;<br><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>	<span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; a.x &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p> 在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。</p>
<p>两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化</p>
<p>其他参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chw1989/article/details/7480375">https://blog.csdn.net/chw1989/article/details/7480375</a></p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>在定义前面加了 static 关键字的成员,本质是全局变量</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CRectengle</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> w ,h;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nTotalArea;   <span class="hljs-comment">//静态成员变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nTotalNumber;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CRectangle</span>(<span class="hljs-keyword">int</span> w_,<span class="hljs-keyword">int</span> h_);<br>    ~<span class="hljs-built_in">CRectangle</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintTotal</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//静态成员函数</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>静态的成员变量，是所有该类的对象共享的，而普通变量是只有对象自己能用。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 另  sizeof 运算符不会计算静态成员变量，因为静态变量实际上不是放在对象内部的，而是在整个对象的外部</span><br><br>如：<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CMclass</span>&#123;</span><br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s;<br>    &#125;;<br>	<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(CMyclass);  <span class="hljs-comment">//结果为4 ，而不是8</span><br><br><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>普通成员函数</p>
<p>必须作用于一个对象，通过对象来调用</p>
</li>
<li><p>静态成员函数</p>
<p>并不具体作用于某个对象，因此不需要通过对象就能访问</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//如何访问静态成员变量、函数？</span><br><br><span class="hljs-comment">//1 类名：：成员名</span><br>	CRectangle::<span class="hljs-built_in">PrintTotal</span>();<br><span class="hljs-comment">//2 对象名.成员名</span><br>	CRrctangle r;<br>	r.<span class="hljs-built_in">PrintTotal</span>();<br><span class="hljs-comment">//3 指针-&gt;成员名</span><br>	CRectangle*p = &amp;r;<br>	p-&gt;<span class="hljs-built_in">Printotal</span>();<br><span class="hljs-comment">//4 引用.成员名</span><br>	CRectangle &amp;ref = r;<br>	<span class="hljs-keyword">int</span> n = ref.nTotalNumber;<br>	<br></code></pre></div></td></tr></table></figure>
<ul>
<li>引入的意义，把和类紧密相关的内容能写到类中去，使得成为一个整体，便于理解维护。</li>
</ul>
<p>比如：记录与类相关的数据，就可以用静态变量，放到类里</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//实例</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CRectangle</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> w,h;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nTotalArea;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nTotalNumber;  <span class="hljs-comment">//私有</span><br>    <span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">CRectangle</span>(<span class="hljs-keyword">int</span> w_,<span class="hljs-keyword">int</span> h_);<br>    ~<span class="hljs-built_in">CRectangle</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintTotal</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br>Crectangle::<span class="hljs-built_in">CRectangle</span>(<span class="hljs-keyword">int</span> w_,<span class="hljs-keyword">int</span> h_)<br>&#123;<br>    w = w_;<br>    h = h_;<br>    nTotalNumber ++;<br>    nTotalArea += w*h;<br>&#125;<br><br>CRectangle::~<span class="hljs-built_in">CRectangle</span>()<br>&#123;<br>    nTotalNumber --;<br>    nTotalArea -= w*h;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CRectangle::PrintTotal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;nTotalNumber&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;nTotalArea&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//特别注意  静态函数必须在定义类的文件中对静态成员变量进行依次说明或初始化，否则编译能通过，链接不能通过</span><br><br><span class="hljs-keyword">int</span> CRectangle：：nTotalNumber=<span class="hljs-number">0</span>; <span class="hljs-comment">//初始化，可以赋初值</span><br><br><span class="hljs-comment">//静态成员函数中，不能访问非静态成员变量，也不能第调用用非静态成员函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CRectabgle::PrintTotal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt;w&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;....  <span class="hljs-comment">//wrong</span><br>&#125;<br><br><span class="hljs-comment">//非静态函数，里面会调用非静态变量，所以也是不可以的</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>缺陷</p>
<p>复制构造函数生成对象初始化，就导致会存在漏洞</p>
</li>
<li><p>临时对象消亡时调用析构函数，影响数值</p>
</li>
<li>要自己写一个复制构造函数，包含对静态变量的操作</li>
</ul>
<h3 id="静态变量和常量"><a href="#静态变量和常量" class="headerlink" title="静态变量和常量"></a>静态变量和常量</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul>
<li>static和const在编译时直接分配内存。</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>（本质）static是类型引用，const是实例引用。</li>
<li>（赋值）静态变量的值在运行时可以更改赋值，而常量的值是不可改变的，运行一开始已经固定，之后修改会报错。</li>
<li>（内存）静态变量存放在全局数据区中，伴随着这个程序流程，能将此变量的值保留到下次调用，不过数据过大的静态变量有可能造成内存泄露。 而const常量算是一个普通的只读变量，随函数结束而结束。在C里，const常量总是会分配内存，位于只读数据段。在C++，如果const常量在没有声明为extern，那么就是一个编译时的符号，不占用内存。</li>
</ul>
<h3 id="成员-对象-和封闭类-enclosing"><a href="#成员-对象-和封闭类-enclosing" class="headerlink" title="成员==对象==和封闭类(enclosing)"></a>成员==对象==和封闭类(enclosing)</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTyre</span>  //<span class="hljs-title">l</span>轮胎类</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> radius;   <span class="hljs-comment">//半径</span><br>    <span class="hljs-keyword">int</span> width;   <span class="hljs-comment">//宽度</span><br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">CTyre</span>(<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> w):<span class="hljs-built_in">radius</span>(r),<span class="hljs-built_in">width</span>(w)&#123;&#125;  <span class="hljs-comment">//需要参数</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CEngine</span>  //引擎类</span><br><span class="hljs-class">&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCar</span>   //这个类就是封闭类</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">int</span> price;<br>        CTyre tyre;   <span class="hljs-comment">//成员对象  ，构造时如果需要参数，调用该类时需要给出参数</span><br>        CEngine engine;   <span class="hljs-comment">//成员对象</span><br>    <span class="hljs-keyword">public</span>:<br>   		 <span class="hljs-built_in">CCar</span>(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> tr,<span class="hljs-keyword">int</span> tw)&#123;&#125;;<br>&#125;;<br>CCar::<span class="hljs-built_in">CCar</span>(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> tr,<span class="hljs-keyword">int</span> w):<span class="hljs-built_in">price</span>(p),<span class="hljs-built_in">tyre</span>(tr,w)<br>&#123;<br>    <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">CCar <span class="hljs-title">car</span><span class="hljs-params">(<span class="hljs-number">20000.17</span>,<span class="hljs-number">225</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>封闭类构造函数和析构函数的执行顺序</strong><ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后执行封闭类的构造函数。</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反。</li>
</ul>
</li>
</ul>
<p>先构造的后析构，先初始化后消亡 </p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//实例</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTyre</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CTyre</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;CTyre contructor&quot;</span> &lt;&lt;endl;&#125;<br>    ~<span class="hljs-built_in">CTyre</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;CTyre destructor&quot;</span> &lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CEngine</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CEngine</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;CEngine contructor&quot;</span> &lt;&lt;endl;&#125;<br>    ~<span class="hljs-built_in">CEngine</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;CEngine destructor&quot;</span> &lt;&lt;endl;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCar</span></span><br><span class="hljs-class">&#123;</span><br> 	<span class="hljs-keyword">private</span>:<br>    	CEngine engine;<br>    	CTyre tyre;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">CCar</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;CCar contructor&quot;</span>&lt;&lt;endl;&#125;<br>    	~<span class="hljs-built_in">CCar</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;CCar destructor&quot;</span> &lt;&lt;endl;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CCar car;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>封闭类的复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;cout &lt;&lt;<span class="hljs-string">&quot;default&quot;</span>&lt;&lt;endl;&#125;<br>    <span class="hljs-built_in">A</span>(A &amp; a)&#123;cout &lt;&lt;<span class="hljs-string">&quot;copy&quot;</span>&lt;&lt;enld;&#125;<br>&#125;;<br><span class="hljs-function">class <span class="hljs-title">B</span><span class="hljs-params">(A a;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b1,<span class="hljs-built_in">b2</span>(b1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="常量对象、常量成员、常引用"><a href="#常量对象、常量成员、常引用" class="headerlink" title="常量对象、常量成员、常引用"></a>常量对象、常量成员、常引用</h3><ul>
<li><p>如果不希望改变某个对象的值，即可以再定义对象前加const关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">int</span> value;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">const</span> Demo Obj;  <span class="hljs-comment">//常量对象</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数</p>
</li>
<li><p>常量成员函数执行期间==不应修改其所作用的对象== 。因此，在常量成员函数中==不能修改成员变量的值(== 静态成员变量除外)，也不==能调用同类的非常量成员函数== (静态成员函数除外)</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>：<br>        <span class="hljs-keyword">int</span> value;<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    	<span class="hljs-built_in">Sample</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sample::GetValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    value = <span class="hljs-number">0</span>;<span class="hljs-comment">//wrong   常量函数内部，不能调用或改变非常量成员</span><br>    <span class="hljs-built_in">func</span>();<span class="hljs-comment">//wrong    常量函数内部，不能调用或改变非常量成员函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> Sample o;<br>    o.value = <span class="hljs-number">100</span>;  <span class="hljs-comment">//err.常量对象不可被修改</span><br>    o.<span class="hljs-built_in">func</span>();     <span class="hljs-comment">//err.常量对象上面不能执行非常量成员函数</span><br>    o.<span class="hljs-built_in">getvalue</span>();   <span class="hljs-comment">//ok. 常量对象上可以执行常量成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//在dev c++中 要为Sample类编写无参构造函数才可以。</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="常量成员函数的重载"><a href="#常量成员函数的重载" class="headerlink" title="常量成员函数的重载"></a>常量成员函数的重载</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTest</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CTest</span>()&#123;n=<span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> n;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*n;&#125;  <span class="hljs-comment">//这里重载了上个函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> CTest objTest1;<br>    CTest objTest2;<br>    cout &lt;&lt; objTest1.<span class="hljs-built_in">GetValue</span>()&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;objTest2.<span class="hljs-built_in">GetValue</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    <br></code></pre></div></td></tr></table></figure>
<h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>&#125;;<br><span class="hljs-comment">//函数参数调用时避免重复多次使用构造函数，提升效率，使用引用</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintfObj</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sample &amp; o)</span>  <span class="hljs-comment">//因为有const，所以不能修改o值</span></span><br><span class="hljs-function"></span>&#123;<br>    .....<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li><p>友元</p>
<ul>
<li><p>友元函数</p>
</li>
<li><p>友元类</p>
</li>
</ul>
</li>
</ul>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>一个类的友元函数可以访问该类的私有成员</p>
<p>友元函数并不是成员函数，友元函数可以是一个全局函数，当把这个全局函数声明为友元的时候，就可以访问该类的私有成员了</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCar</span>;</span>  <span class="hljs-comment">//这里起提前声明的作用，以便CDriver类使用</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDriver</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ModifyCar</span><span class="hljs-params">(CCar *pCar)</span></span>; <span class="hljs-comment">//改装车，如果这里不是一个指针而是一个类，则需要把CCar在上面写完整</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCar</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">int</span> <span class="hljs-title">MostExpensiveCar</span><span class="hljs-params">(CCar cars[],<span class="hljs-keyword">int</span> total)</span></span>;  <span class="hljs-comment">//声明友元，并不是成员函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CDriver::ModifyCay</span><span class="hljs-params">(CCAr * pCar)</span></span>;  <span class="hljs-comment">//声明友元，不是成员函数，而是上一个类的成员函数，这里把这个函数声明为CCar的友元</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CDriver::ModifyCar</span><span class="hljs-params">(CCar * pCar)</span>  <span class="hljs-comment">//全局函数</span></span><br><span class="hljs-function"></span>&#123;<br>    pCar-&gt;price += <span class="hljs-number">1000</span>;  <span class="hljs-comment">//这里访问了类的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MostExpensiveCar</span><span class="hljs-params">(CCar car[],<span class="hljs-keyword">int</span> total)</span>  <span class="hljs-comment">//全局函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> tmpMax = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;total; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cars[i].pricr &gt; tmpMax)<br>        &#123;<br>            tmpMax = cars[i].price;  <span class="hljs-comment">//访问量私有成员</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tempMax;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-keyword">int</span> num;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B::function</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//这里使 类B 的成员函数成为 类A 的友元，这样 类B 的成员函数function就可以访问 类A 的私有成员 num了</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>如果A是B的友元，那么A的成员函数可以访问B的私有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCar</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> price;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDriver</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDriver</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>：<br>        CCar myCar;<br>    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ModifyCar</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//改装汽车</span><br>            myCar.price += <span class="hljs-number">1000</span>;  <span class="hljs-comment">//因CDriver是CCar的友元类，</span><br>                                 <span class="hljs-comment">//故此处可以访问其私有成员</span><br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-comment">//友元类之间的关系不能传递，不能继承</span><br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/13/C++3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++系列：运算符重载（三）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/13/C++1/">
                        <span class="hidden-mobile">C++系列：C++与C的区别（一）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"UrMBdkpVtSriHxFtNjQRvPqm-gzGzoHsz","appKey":"rLGXsY7AM0Ym431NbB2fCRpX","path":"window.location.pathname","placeholder":"发一条友善的评论","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <p style="text-align:center;">如果博文对你有帮助，可以给博主充充电噢~ <br> 非常感谢！！</p><img src="/img/qxd.jpg" srcset="/img/loading2.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  




  
<script src="/js/diy/timeDate.js"></script>
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/Metingjs@1.2/dist/Meting.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"}});</script></body>
</html>
